Запуск сервисов локально:

`make up-services`

Выполнить миграции на локальную базу данных:

`make forward_migrations_head_local`

Первый Debug в PyCharm:
1. Создать новую конфигурацию для Python
2. Выбрать интерпретатор Python
3. Указать путь до скрипта `manage.py`
4. Добавить аргумент (для runserver: "runserver"; для run_consumer: "run-consumer")
5. Указать рабочую директорию - корень проекта
6. Указать путь до одного из .env-файлов в директории `envs/`
7. Запустить Debug

Swagger: `http://localhost:8010/docs`

Панель администратора: `http://localhost:8010/admin/`

Некоторые команды из Makefile не запускаются через конфигурацию Makefile, т.к. там не подключается виртуальное окружение.
Запуск таких команд из Makefile в PyCharm:
1. Создать конфигурацию для Shell Script
2. Выбрать Script Text
3. Ввести команду в текстовое поле, например `make alembic_upgrade_head`
4. Выполнить конфигурацию

Запустить celery worker:

`make up-celery-worker`

Запустить celery flower:

`make up-celery-flower`

Проект разрабатывается с помощью курса https://stepik.org/course/153849/promo

TODO:
1) Посмотреть все TODO в коде
2) Найти причину использовать fastapi lifespan (resource.setup() and resource.close())
3) Проверять подключение к бд при старте приложения (Lifespan) (ping)
2) Все миграции откатить до начала и готовую бд сделать первой ревизией
`alembic revision --autogenerate -m "Initial migration"`
3) создать example.env
4) придумать что-нибудь с submodule (например, модели) и со своей библиотекой
6) Перейти на SQLModel
9) id: uuid.UUID
10) Попробовать autoflake8
11) pre-commit
13) Разобраться с енвами для бд (число пулов и тд)
15) Написать свой json сериалайзер, чтоб не делать json.loads(json.dumps(
16) Ошибки писать в логи, в sentry, kibana (подробно, с трейсом)
17) Сериализация исключений. Что-то про респонс-модел
18) Вспомнить, когда была ошибка TypeError (в апишке или в репо)
19) Вместо json использовать orjson (или другие альтернативы). Если вообще нужен будет
21) До конца реализовать базовый репо.
24) Переписать dump.sql так, чтоб запросы возвращали id, которые можно потом использовать в следующих запросах
25) зачем rooms_quantity в hotels, оно скорее всего не верное, с подсчетом rooms не связано. Но в целом можно добавить процедуру по изменению при различных операциях
26) rooms - это, скорее тип комнаты, а не сама комната, потому что в отеле есть определенный тип (категория) комнаты и определенное количество таких комнат
27) pydantic_factory можно использовать для быстрой генерации данных
30) Одна из ошибок не ловилось в ручке catcher-ом. Из-за отсутствия `await` ошибка в `return booking_service.create_booking(booking_input, user_id=user.id)`
31) Заново создать бд, запустить dump.sql скрипт. Он создаст 3 пользователя. Потом с помощью ручки sign_up добавить пользователя. Будет ругаться на попытку сгенерировать существующий id. 3 раза ручка возвращает ошибку, а на 4ый раз создает
32) поиграть с ручками, когда таблицы будут пустыми
33) во все методы прописать типы для параметров
35) почитать про aioredis[hiredis], в проекте используется redis.asyncio
36) Приложения, консьюмеры и тд из manage.py запустить в докере (+celery) (например, запустить как utils/linters)
37) Для celery можно почитать https://github.com/celery/celery/issues/8724, чтобы задать корректно разрешения
38) Залесть на сайт docker на python (почитать про alpine, bookworm и тд)
39) Flower не показывает задачи со state "started". Только после выполнения показывает задачи со state "success"
40) Поработать с двумя очередями celery https://habr.com/ru/articles/269347/
41) dump.sql у всех пользователей в пароли прописать хеши паролей, а не текст
42) Почитать доку https://aminalaee.dev/sqladmin/
43) Понять разницу backref и back_populates в sqlalchemy.orm.relationship